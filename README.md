# contract

## 简介

* ddd，ddd是 domain driven design 简称，叫领域驱动设计。contract是我个人对团队开发的理解，意思为沟通合作。

*

我们先看ddd，驱动设计从字面意思很好理解，是指导我们设计的一种思想，类似的还有测试驱动开发等等，关键在于领域一词，这个概念很抽象宽泛，网络定义也是五花八门，例如："
一个组织所做的事情以及包含的一切"、"客户使用软件要处理旳问题种类即为软件的领域"、"业务相关知识的集合"
等等，个人觉得最后一个解释比较贴切，实际上也正是这个模糊的概念导致落地带来了很多问题。
比如有些时候我们把业务抽象的较细，这会导致我们实现一个功能的时候变得复杂，需要跨越很多"领域"
，甚至在一些特定的业务内，数据一致性还面临挑战，总体来说成本变高，收益变小，
那么抽象的粒度如何控制？换个问题就好比说我们为什么需要领域驱动，一个概念也好技术也好，它的出现一定是为了解决某个问题，我个人觉得这是一个很好的问题，那么我们来看一下领域驱动这个概念出现的时间和场景。

* 领域驱动概念来自2004年 Eric Evans 的一本书籍，英文叫《Domain-Driven Design –Tackling Complexity in the Heart of
  Software》，作者在书中的前言写了自己的三个失败案例

  + 一个web交易系统，没有模型设计，但是因为早期的业务简单，也获得了成功，只是在后来的不断迭代中，作者是后来的迭代中被邀请，可是开发仍然不重视模型设计，后来系统僵化，项目就失败了，
    这个例子和我们真实生活多么相似，早期简单也收获一些成功，但是随着业务发展，系统变的越来越僵化，最后以失败告终。这个案例可以告诉我们这样几个道理。
    + 也不是一开始就需要很好的模式设计，因为复杂设计意味成本变高，设计上有一个叫KISS 原则（Keep It Stupid
      Simple），就是说不要把简单的事情变的复杂，系统不是设计出来的，系统就像产品本身一样，是迭代出来的，所以过度设计除了增加成本，还会引入风险。
    + 业务发展过程中（业务逻辑变得复杂，对象不断增加，对象间关系变得复杂），开发需要越来越重视业务逻辑并不断完成模型抽象，才能应付业务发展

  + 第二个是为贸易机构提供的一个简单程序，初期也获得一定成功，后来每次迭代，书中是这样描述的，"
    开发团队按照要求提供了灵活性和扩展性，反复精化领域模型，并得以在代码中体现，最终设计不断没有加重负担，反而易于修改和扩展"
    ，那么从这个例子中我们也可以知道
    + 成功的或者说好的系统并非一蹴而就，而是不断沟通不断提炼，我们经常听到一句话叫，系统是演化的，不是一开始就能设计出完美系统
    + 不断迭代中需要不断的沟通增加理解，不断的思考抽象代码，那么未来面对需求，就会游刃有余

  + 第三个项目是一个企业系统，非常重视模型分析，但是最终失败了？为什么，书中是这样说的："
    团队将开发独立出来，导致建模和实现脱节"，这说明什么，我总结如下
    + 用户、产品分析、编码实现现在已经产生了明确的分工，实际上为了完成一个产品，三者是密不可分，需要共同参与来实现的，文字也好视频也好，只是为了辅助我们对产品的理解，我们真正对产品的理解决定了产品的成败，所以频繁的沟通是至关重要的
    + 有时候大家都懂，不一定是真正理解对方，我们需要一个"通用语言"尽可能的消除理解上的差异，此外导致差异也可能是角度不一样，如果是这样，那么差异需要封装到不同的领域中

* 综上所述，我们就可以理解 Eric Evans
  为什么要写这样一本书，实际上我个人经历和作者非常相似，可见作者也是总结过去的经历，希望从中寻找到解决问题的方法，大多数的教程和博客（例如《实现领域驱动设计》）都在说领域、边界、值对象、聚合根等等，还有书中的各类架构，我个人觉得，从原始问题触发，更容易理解概念和意图。

* 首先看 Eric Evans
  是怎么解决上面这些场景的出现的问题呢？我根据《领域驱动设计》内容做了一个归纳，但是书中的逻辑，和我们现实中的实践有一定差距，我自己结合一个大多数开发流程，在流程中插入ddd中的思想，这样可能更容易理解或者实践，我们一般开发流程如下：

  + 需求分析：很多公司这项工作是由产品岗位来完成，所以开发参与较少甚至没有参与，
    我个人结合自身经验和书中的思想来说，如果有机会的化，还是希望开发能够参与，为什么呢？

    + 这里是需求最初始的来源，了解需求的背景有助于我们更好理解需求。

    + 如果说这个需求是来源某个数据分析，那么观察数据可以辅助我们建立模型，甚至做系统设计的时候可以对针性对做一些数据落地，因为业务产生本身也是为了验证解决数据中的问题，这类业务我们也可以称为数据驱动，
      -
      观察数据可以帮我们分析业务方向，保证业务前进方向是正确的，这里方向正确不是说这样做一定对一定有结果，而是针对数据模型我们目标没有偏差，就像做实验一样，实验可能有成功有失败，但是实验目标不能错，也许有人说，这不是产品职责吗，确实如此，但是我相信每个人都有这样的经历，
      "你这样的设计能达到效果吗？"，"有实际解决用户的问题？"等等，当然我们也可以在需求讲解的时候提出来，这里分析很关键，因为如果这里发生比较大的问题，那么后面工作都是白费了。

    + 还有一类是根据业务方提出的需求，这类业务在toB的系统中较多，toB系统一般都有成熟且复杂的领域模型，这里我们开发如果能够和领域专家积极沟通化，那么
      - 建立准确的模型：也许刚开始系统比较简单，不需要什么模型分析也可以得到一个比较不错的系统，但是我们都要清楚的认识到，之所以有一个好的开始不是因为我们的技术水平高，而是系统在开始的时候并不复杂，建立一个准确的模型有力业务沟通
      -
      易扩展：随着业务发展，越来越多的对象产生，关系也越来越复杂，这里时候就需要小步重构，小步重构是可以解决问题的，但是如果我们刚开始就能意识到问题并埋下伏笔，在扩展的时候不是更加游刃有余吗，那么我们如何意识到扩展点，这里沟通和分析就显得尤为重要，领域专家可以帮助我们得到这些扩展点。

    + 头脑风暴：通过不同的个体充分的表达，可以促进对问题的分析，简单来说，集思广益，一个团队的思考结果一般来说大于个人

  + 系统分析

    + 统一语言：需求的目标和方向确定了，接下来就是系统分析，首先来说一个关键技术，叫统一语言，英文叫UBIQUITOUS
      LANGUAGE，为什么需要统一语言，我们经常听到这样一些对话，"原来你说的是这个意思啊"、"那你没有说清楚啊"、"
      你没有说我哪里知道"，
      之所以产生认识偏差，是因为我们没有基于一个统一语言，统一语言好处也就是消除认识偏差，
      例如可以使用UML，这不是必须的，如果团队合作非常默契，对领域的认识已经非常深入，那么简单的草图也是可以的，只要能够准确表达意思即可，但是在初期，还是建议采用类似UML，因为初期大家可能对领域内的概念、术语认识不是那么深刻，那么尽可能详细的描述只有好处没有坏处，包括文档。
      一般而言，一套语言从属一个领域。

    +
    消化和学习：我们需要对用户场景进行深入分析，识别对象和关系，这一步是简单的，但是还不够，如果系统只有简单的对象和关系，那么系统内部的调用将会呈现网状（例如采用三层架构），使得系统在后续迭代（更多的对象和关系，不加约束的声明）中面临困难，
    所以我们还需要进一步梳理，我们需要梳理出，对用户来说具有价值且能够独立存在的对象，我们把它们称为聚合根，剩下的对象我们再梳理出从属（关系上表现为：被引用、组合块）与哪个聚合根，这个过程我们称为聚合。
    这个扩展的过程我们会发现很多相似的对象，这些对象有时候不能简单合并，首先要看表达的含义，即在统一语言中的定义。
    有了聚合根，我们可以进一步扩展出边界，即界限上下文，上下文进一步约束了不同领域的之间的交互，领域之前不能直接交互，必须通过上下文，书中有个很形象的比喻，细胞之间通过细胞壁交互，限定交互发生的场地，也屏蔽了各个细胞内部的细节。
    其他概念总结如下（不是完全按照书中来，根据个人理解，总结出带有指导性的解释）：
    - 值对象：一组属性集合，作为整体变化，没有标识定义
    - 实体：带有标识定义的对象，组合多个值对象和一个明确的标识，但是实体不能直接与外部交互
    - 聚合根：可以独立提供价值的实体，可以持有其他实体，负责和外部交互并维护内部各个实体的规则
    - 领域：持有多个聚合根、实体、值对象，但是聚合根、实体、值对象的统一语言不能发生改变，例如物流系统的订单和商品系统里面订单很可能长的一样，但是却不是一样的含义。
      一个领域可以进一步切分多个子域，个人觉得看需要。
    - 上下文：也可以称为边界，一个领域可以导出一个上下文，提供给外界访问
    -
    上下文映射：不同的领域都有自己的上下文，这个上下文在交互的时候，实体所表示的含义是不同的，需要映射来转换，这样做的好处是维护来领域内部的稳定性，如果上下文发生变化，映射会失败，不会影响到领域内部，书中有另外一些解决方法，具体可以自行参考

    +
    模型和实现绑定：这是一个我过去用的比较少的一种技术，也是因为囿于技术环境或者说是氛围，我们一直认为，产品和代码实现是两个东西，产品不需要了解技术细节，开发不需要了解产品知识，事实上如果说产品设计和技术相脱离，真的可以实现一个复杂的系统吗？我个人深刻教训告诉我，很难。
    我曾经在一个团队开发一个比较复杂的系统，系统内部有非常专业的流程、专业概念、专业术语，但是团队忽略了一个问题就是想当然的把系统设计和产品设计相分离，最终在后续迭代中，会出现一些奇怪的问题，这里问题只有开发知道，产品无法判断到这些问题的来临，是为什么呢？就是因为开发设计和产品设计并不一致。
    我个人觉得我们web开发从某个角度来说其实是业务翻译，就是利用我们掌握的语言对产品需求进行翻译，所以我们的领域模型和产品的真实实现需要建立映射关系，我们的每一行代码都能表述业务中的业务知识，其实像java、c++等语言，语言本身支持面向特性（封装、继承、多态），所以实现现实场景的映射是非常简单的。

    +
    设计文档：文档不是必须，特别是很多人认为代码本身就是文档，我个人是不认同的，首先就如同我写下这些文字一样，很多人对于文章的理解也不一样，同样是学中国字，同样是学习编程，为什么还是有差异，我们必须要认识到语言对事物的解释是有缺陷的，所以清晰的表达，换位表达，写出别人能够理解的代码非常重要。我们的实际工作中，我们需要注意代码可读性（类名、方法签名、变量命名），注意提交代码的注释，编码风格等等。

    + 开发一个丰富知识的模型：这里说的就是我们经常听到的充血模型了，模型不仅仅是数据的载体，还能够表示其丰富的概念。例如实体有自己的属性和属性的完整性约束，拥有自己的方法，负责从属对象的生命周期和业务规则维护

    +
    分层架构：这是我们抽象出一个通用的分层架构，与传统的三层架构，领域驱动中多了一个领域层，也就是我们之前不断分析聚合得到的领域，其实很多操作可以直接请求到领域层，服务层（书中写的是应用层）职责被明确为，一个动作不能放到某个领域中（不属于某个具体领域，操作了多个领域），则可以声明为服务

  + 编码

    +
    深入模型、模型提炼：随着业务发展，我们对模型理解越来越深入，模型的优势和劣势也会逐步显露出来，这个时候就需要提炼模型，代码表现就是小步重构，提到重构，个人觉得首先是勇气，因为我们总是面临这产品、测试、内部外部的压力，重构本身也是吃力不讨好的一件事，所以具体业务具体分析，不做展开，重构技术可以参考《重构》这本书

    + 结对编程：自己理解自己的写的代码，但是别人不一定。结对编程提供可以实践的方式，另外编码会陷入细节之中，缺乏全局视角，结对编程可以提供这种视角。

  + 测试

    + 测试驱动开发：尽可能尽早的发现问题，降低错误成败，此外重构以后系统也面临的巨大的风险，测试驱动保证重构是安全的。

### 参考目录

https://domain-driven-design.org/zh/ddd-concept-reference.html#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1ddd
https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice
https://tech.meituan.com/2017/12/22/ddd-in-practice.html
https://zhuanlan.zhihu.com/p/356518017
